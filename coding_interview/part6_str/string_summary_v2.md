#문자열 파트 요약
##1.리스트의 pop(0) 은 O(n)이다. 하지만 데크의 popleft()는 O(1)이다.  
##2.파이썬은 문자열을 배열이나 리스트처럼 슬라이싱할 수 있는 기능을 제공한다.  
슬라이싱은 내부적으로 C로 구현되어 있어 빠른 속도를 기대할 수 있다.  
####슬라이싱  
s="안녕하세요"  
s[1:4] : 녕하세  
s[1:-2] : 녕하 (음수로 접근할 경우 -5 부터 -1)  
s[:] : 안녕하세요  
(파이썬은 a=b 와 같은 형태로 할당하면 변수의 값이 할당되는 것이 아니라  
a변수가 b변수를 참조하는 형태가 된다.  
참조가 아닌 값을 복사하기 위해서 [:]를 사용할 수 있다. (Pythonic way)    
s[1:] : 녕하세요  
s[1:100] : 녕하세요 (s[1:]와 동일)  
s[-1] : 요  
s[-4] : 녕  
s[:-3] : 안녕  
s[::1] : 안녕하세요  
s[::-1] : 요세하녕안  
s[::2] : 안하요  
##3.[::-1] 이 안되는 경우 s[:]=s[::-1] 로 한다.  
##4.람다 표현식  
####람다식 
람다 표현식 : 식별자 없이 실행 가능한 함수, 함수 선언 없이도 하나의 식으로 함수를 단순하게
표현한다. 
```python
s=['2 A','1 B','4 C','1 A']

def func(x):
    return x.split()[1],x.split()[0]
s.sort(key=func)

#람다식 사용
s.sort(key=lambda x:(x.split()[1],x.split()[0]))
```
람다 표현식은 코드가 길어지고 map이나 filter와 함께 사용할 경우 가독성이
많이 떨어질 수 있으므로 주의가 필요하다.  

##5.유니코드와 UTF-8
초기에는 대부분 ASCII 인코딩 방식으로, 1byte 에 모든 문자를 표현했다.
게다가 1bit 는 Checksum 으로 제외하여 7bit, 즉 128 글자로 문자를 표현했다. 
그러다 보니 한글이나 한자 같은 문자는 2개 이상의 특수 문자를 합쳐서 표현해는데, 이런 방식은
제대로 문자를 표현하지 못하였다.  
이를 해결하기 위해 2~4byte 공간에 여유 있게 문자를 할당하고자 등장한 방식이 '유니코드(Unicode)' 이다.  
그러나 유니코드는 1byte 로 표현가능한 영문자 또한 2byte로 표현했기 때문에 메모리의 낭비가 심했다.  
이를 가변 길이 문자 인코딩 방식으로 효율적으로 개선한 방식이 'UTF-8'이다.  


